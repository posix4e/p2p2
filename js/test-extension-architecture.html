<!DOCTYPE html>
<html>
<head>
    <title>P2P2 Extension Architecture Demo</title>
    <style>
        body { font-family: monospace; padding: 20px; max-width: 800px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        .success { background: #d4edda; color: #155724; }
        .info { background: #d1ecf1; color: #0c5460; }
        code { background: #f8f9fa; padding: 2px 5px; border-radius: 3px; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>P2P2 Extension Architecture Demo</h1>
    
    <div class="section info">
        <h2>How Chrome Extensions Bypass CORS</h2>
        <p>Chrome extensions can bypass CORS restrictions through their background scripts:</p>
        <ol>
            <li>The extension declares <code>host_permissions</code> in manifest.json</li>
            <li>Content scripts and popups send requests to the background script</li>
            <li>The background script makes the actual HTTP requests</li>
            <li>Responses are sent back to the requesting script</li>
        </ol>
    </div>
    
    <div class="section">
        <h2>Architecture Implementation</h2>
        <h3>1. manifest.json</h3>
        <pre>{
  "manifest_version": 3,
  "host_permissions": [
    "https://api.cloudflare.com/*"
  ],
  "background": {
    "service_worker": "background.js"
  }
}</pre>
        
        <h3>2. ChromeExtensionAdapter</h3>
        <pre>class ChromeExtensionAdapter {
  async fetch(url, options) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'fetch', url, options },
        (response) => {
          // Handle response from background script
        }
      );
    });
  }
}</pre>
        
        <h3>3. Background Script</h3>
        <pre>chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.type === 'fetch') {
    fetch(request.url, request.options)
      .then(response => /* serialize and send back */)
      .catch(error => /* handle error */);
    return true; // Async response
  }
});</pre>
        
        <h3>4. Usage in P2P2</h3>
        <pre>// CloudflareDNSDiscovery uses adapter's fetch if available
const response = await this.fetchWithAdapter(url, {
  headers: { 'Authorization': `Bearer ${this.apiToken}` }
});

// In extension context, this routes through background script
// In Node.js context, this uses native fetch
// Transparent to the library code!</pre>
    </div>
    
    <div class="section success">
        <h2>Benefits</h2>
        <ul>
            <li>✅ No CORS restrictions in Chrome extensions</li>
            <li>✅ Same codebase works in Node.js and browser extensions</li>
            <li>✅ No proxy server needed</li>
            <li>✅ Direct API calls to Cloudflare</li>
            <li>✅ Transparent to the library consumer</li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Testing the Extension</h2>
        <p>To test this architecture:</p>
        <ol>
            <li>Load the extension in Chrome: chrome://extensions/</li>
            <li>Enable Developer mode</li>
            <li>Click "Load unpacked" and select the extension-test directory</li>
            <li>Click the extension icon to open the popup</li>
            <li>Click "Connect" to test P2P functionality</li>
        </ol>
    </div>
</body>
</html>